// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `expand_env_vars`, `from_map`
// These types are ignored because they are not used by any `pub` functions: `PluginIdentifier`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `hash`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PluginManager>>
abstract class PluginManager implements RustOpaqueInterface {
  Future<List<PluginItem>> filterPlugin(
      {required String name,
      required List<(String, String)> config,
      required String query});

  Future<List<PluginItem>> initPlugin(
      {required String name, required PluginConfig pluginConfig});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<PluginManager> newInstance() =>
      RustLib.instance.api.crateApiPluginManagerPluginManagerNew();

  Future<void> select(
      {required String name,
      required List<(String, String)> config,
      required String elementName});
}

class PluginConfig {
  final String wasmPath;
  final List<String> allowedPaths;
  final List<String> allowedHosts;
  final bool enableWasi;
  final List<(String, String)> config;

  const PluginConfig({
    required this.wasmPath,
    required this.allowedPaths,
    required this.allowedHosts,
    required this.enableWasi,
    required this.config,
  });

  @override
  int get hashCode =>
      wasmPath.hashCode ^
      allowedPaths.hashCode ^
      allowedHosts.hashCode ^
      enableWasi.hashCode ^
      config.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginConfig &&
          runtimeType == other.runtimeType &&
          wasmPath == other.wasmPath &&
          allowedPaths == other.allowedPaths &&
          allowedHosts == other.allowedHosts &&
          enableWasi == other.enableWasi &&
          config == other.config;
}

class PluginItem {
  final String name;
  final String description;
  final String icon;

  const PluginItem({
    required this.name,
    required this.description,
    required this.icon,
  });

  @override
  int get hashCode => name.hashCode ^ description.hashCode ^ icon.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginItem &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          description == other.description &&
          icon == other.icon;
}
